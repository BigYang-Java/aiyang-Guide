# Spring Boot 事务

## 事务

### 什么是事物

事务是将一组操作封装成一个执行单元。类似A给B转账，A的转出操作，与B的转入操作，要么同时成功，要么同时失败。

### 事务都有 ACID 特性：

1.  原子性（Atomicity） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
2.  一致性（Consistency）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；
3.  隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
4.  持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

### 并发事务会带来一些问题。

1.  脏读：脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了并一定最终存在的数据，这就是脏读。
2.  可重复读：可重复读指的是在一个事务内，最开始读到的数据和事务结束前的任意时刻读到的同一批数据都是一致的。通常针对数据更新（UPDATE）操作。
3.  不可重复读：对比可重复读，不可重复读指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。通常针对数据更新（UPDATE）操作。
4.  幻读：幻读是针对数据插入（INSERT）操作来说的。假设事务A对某些行的内容作了更改，但是还未提交，此时事务B插入了与事务A更改前的记录相同的记录行，并且在事务A提交之前先提交了，而这时，在事务A中查询，会发现好像刚刚的更改对于某些数据未起作用，但其实是事务B刚插入进来的，让用户感觉很魔幻，感觉出现了幻觉，这就叫幻读。

### 事务的隔离级别

不同的事务的隔离级别可以解决上面的一些问题，这里说一下事务的隔离级别。 SQL 标准定义了四种隔离级别。这四种隔离级别分别是：

1.  读未提交（READ UNCOMMITTED）
2.  读提交 （READ COMMITTED）
3.  可重复读 （REPEATABLE READ）
4.  串行化 （SERIALIZABLE）

### 下面展示了 4 种隔离级别对这三个问题的解决程度。

![](./attachments/2.table.html)

## spring boot 声明式事务

只需要在方法上添加@Transactional注解就可以实现，无需手动开启和提交事务，如果中途发生异常就会自动回滚事务。

### Transactional 注解的属性信息

![](./attachments/3.table.html)

### Spring事务传播机制

1.  PropaaationREQUIRED:默认的事务传播级别，它表示如果当前存在事务，则加入该事务;如果当前没有事务，则创建一个新的事务。
2.  PropaqationSUPPORTS:如果当前存在事务，则加入该事务;如果当前没有事务，则以非事务的方式继续运行。
3.  Propagation.MANDATORY:(mandatory:强制性)如果当前存在事务，则加入该事务;如果当前没有事务，则抛出异常。
4.  Propaaation.REQUIRES NEW:表示创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，PropagationREQUIRES NEW修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。
5.  Propagation.NOT SUPPORTED:以非事务方式运行，如果当前存在事务，则把当前事务挂起。
6.  Propagation.NEVER:以非事务方式运行，如果当前存在事务，则抛出异常。
7.  Propagation.NESTED:如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行;如果当前没有事务，则该取值等价于PROPAGATION\_REQUIRED。

### spring 事务隔离级别

Isolation.DEFAULT ： 以连接的数据库的事务隔离级别为主

Isolation.READ\_UNCOMMITTED ： 读未提交

Isolation.READ\_COMMITTED： 读提交

Isolation.REPEATABLE\_READ ：可重复读

Isolation.SERIALIZABLE：

  

原文地址：[spring boot 事务](https://zhuanlan.zhihu.com/p/641977368) 


